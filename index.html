<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Moripin: Starfighter</title>
    <style>
        :root {
            --bg: #050510;
            --neon-blue: #00f3ff;
            --neon-red: #ff0055;
            --gold: #ffd700;
            --ui-bg: rgba(0, 10, 30, 0.85);
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg);
            font-family: 'Segoe UI', 'Orbitron', sans-serif;
            color: white;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }

        canvas { display: block; touch-action: none; }

        /* --- UI Common --- */
        .screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 50;
            pointer-events: auto;
            touch-action: none;
        }
        
        .hidden { display: none !important; }

        button {
            background: linear-gradient(135deg, #0044cc, #0088ff);
            border: 2px solid var(--neon-blue);
            color: white;
            padding: 15px 40px;
            font-size: 20px;
            font-weight: bold;
            margin: 10px;
            cursor: pointer;
            border-radius: 5px;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.2s;
            box-shadow: 0 0 15px rgba(0, 243, 255, 0.3);
            min-width: 200px;
        }
        button:hover {
            transform: scale(1.05);
            background: linear-gradient(135deg, #0055dd, #0099ff);
            box-shadow: 0 0 25px rgba(0, 243, 255, 0.6);
        }
        button.secondary {
            background: #333;
            border-color: #666;
        }

        /* --- Main Menu --- */
        #main-menu {
            background: rgba(0,0,0,0.4); /* See-through for auto-play */
            backdrop-filter: blur(2px);
        }
        .title-logo {
            font-size: 60px; /* Reduced for mobile fit */
            font-weight: 900;
            color: #fff;
            text-shadow: 0 0 20px var(--neon-blue), 0 0 40px var(--neon-blue);
            margin-bottom: 40px;
            font-style: italic;
            text-align: center;
            line-height: 1.2;
        }

        /* Mobile Adjustments */
        @media (max-width: 768px) {
            .title-logo { font-size: 40px; }
            button { 
                padding: 20px 50px; /* Larger hit area */
                font-size: 22px; 
                width: 80%; 
                margin: 15px 0;
            }
            .shop-grid { grid-template-columns: 1fr; } /* Stack shop items */
            .shop-item { width: 90%; margin: 0 auto; }
            
            .card-container { flex-direction: column; align-items: center; } /* Stack cards */
            .card { width: 80%; height: auto; min-height: 120px; flex-direction: row; text-align: left; padding: 15px; }
            .card-icon { margin-bottom: 0; margin-right: 20px; font-size: 30px; }
            .card-desc { font-size: 14px; }
            
            #hud .hud-top { flex-direction: column; gap: 5px; top: 10px; }
            .stats-panel { top: auto; bottom: 20px; left: 20px; font-size: 12px; } /* Move stats to bottom left */
            .wave-info { font-size: 18px; top: 10px; right: 10px; }
        }
        #shop-screen {
            background: var(--ui-bg);
            backdrop-filter: blur(10px);
        }
        .shop-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin: 30px 0;
        }
        .shop-item {
            background: rgba(255,255,255,0.05);
            border: 1px solid #444;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            width: 200px;
        }
        .shop-item h3 { margin: 0 0 10px 0; color: var(--neon-blue); }
        .shop-item p { font-size: 14px; color: #aaa; }
        .shop-cost { color: var(--gold); font-weight: bold; margin: 10px 0; display:block; }
        .shop-lvl { font-size: 12px; color: #fff; background: #333; padding: 2px 8px; border-radius: 10px; }

        /* --- HUD (Mobile Optimized) --- */
        #hud {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 10;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        
        /* Top Info (Gold, Score, Wave) */
        .hud-top-container {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 10px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
            padding-bottom: 20px;
        }
        
        .resource-row {
            display: flex;
            gap: 15px;
            font-size: 16px; /* Smaller for mobile */
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px black;
        }
        
        .wave-info {
            font-size: 14px;
            color: #aaa;
            margin-top: 2px;
        }

        /* Stats Panel (Bottom Left) */
        .stats-panel {
            position: absolute;
            top: 10px; left: 10px; /* PC: Top Left */
            background: rgba(0,0,0,0.5);
            padding: 8px;
            border-radius: 5px;
            border: 1px solid rgba(255,255,255,0.1);
            color: #ddd;
            font-size: 11px;
            min-width: 80px;
            backdrop-filter: blur(2px);
        }
        
        /* Mobile Specific Overrides */
        @media (max-width: 768px) {
            .resource-row { font-size: 14px; gap: 10px; }
            .wave-info { font-size: 12px; }
            
            .stats-panel {
                top: auto; bottom: 10px; left: 10px; /* Mobile: Bottom Left */
                font-size: 10px;
                padding: 5px;
                background: rgba(0,0,0,0.3); /* More transparent */
                border: none;
            }
            .stats-panel div { margin-bottom: 2px; }
            
            /* HP Bar at bottom center, slightly higher */
            .hp-bar-container {
                position: absolute;
                bottom: 20px; left: 50%;
                transform: translateX(-50%);
                width: 60%; height: 10px;
                top: auto; /* Reset top */
            }

            .card-container {
                flex-direction: row;
                justify-content: center;
                gap: 8px;
                margin-top: 15px;
                width: 92%; /* 90-92% for clear side margins */
                box-sizing: border-box;
            }
            .card {
                flex: 1; /* Equal width distribution */
                width: auto;
                height: auto;
                min-height: 90px; /* Reduced from 110 */
                padding: 8px 2px; /* Reduced padding */
                flex-direction: column;
                text-align: center;
                border-radius: 6px;
                background: rgba(32, 32, 64, 0.95);
                box-sizing: border-box;
            }
            .card-icon {
                font-size: 18px; /* Smaller icon */
                margin-bottom: 5px;
                margin-right: 0;
            }
            .card-title {
                font-size: 11px; /* Smaller font */
                margin-bottom: 3px;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
                width: 100%;
            }
            .card-desc {
                font-size: 9px; /* Smaller font */
                line-height: 1.1;
            }
        }
            position: absolute;
            top: 50px; left: 50%;
            transform: translateX(-50%);
            width: 400px; height: 20px;
            background: #222;
            border: 2px solid #555;
            border-radius: 10px;
            overflow: hidden;
        }
        #hp-fill {
            height: 100%; width: 100%;
            background: var(--neon-red);
            transition: width 0.2s;
        }

        /* --- Level Up --- */
        #levelup-screen {
            background: rgba(0,0,0,0.9);
        }
        .card-container { display: flex; gap: 15px; margin-top: 20px; }
        .card {
            background: #1a1a2e;
            border: 2px solid #334;
            border-radius: 8px;
            padding: 15px;
            width: 160px; /* Reduced from 200 */
            height: auto; /* Reduced from 280 */
            min-height: 180px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
            display:flex; flex-direction:column; align-items:center;
        }
        .card:hover { transform: translateY(-5px); border-color: var(--neon-blue); background: #202040; }
        .card-icon { font-size: 32px; margin-bottom: 10px; }
        .card-title { font-size: 16px; color:white; font-weight:bold; margin-bottom:8px; }
        .card-desc { font-size:12px; color:#aaa; line-height: 1.3; }

    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <!-- Main Menu -->
    <div id="main-menu" class="screen">
        <div class="title-logo">MORIPIN<br><span style="font-size:0.8em; color:#fff;">STAR FIGHTER</span></div>
        <button onclick="app.startGame()">START MISSION</button>
        <button onclick="app.openShop()" class="secondary">HANGAR (SHOP)</button>
        <button class="secondary">SETTINGS</button>
        <div style="margin-top: 20px; color: var(--gold); font-size: 20px; font-weight: bold;">
            TOTAL GOLD: <span id="menu-gold">0</span>
        </div>
    </div>

    <!-- Shop Screen -->
    <div id="shop-screen" class="screen hidden">
        <h1>HANGAR UPGRADES</h1>
        <div style="color: var(--gold); font-size: 24px; margin-bottom: 20px;">
            CREDITS: <span id="shop-gold-display">0</span>
        </div>
        <div class="shop-grid">
            <div class="shop-item">
                <h3>HULL PLATING</h3>
                <p>Start with more HP</p>
                <span class="shop-lvl" id="lvl-maxHp">Lv. 0</span>
                <span class="shop-cost" id="cost-maxHp">100 G</span>
                <button onclick="app.buyUpgrade('maxHp')">UPGRADE</button>
            </div>
            <div class="shop-item">
                <h3>MAGNET FIELD</h3>
                <p>Base item pickup range</p>
                <span class="shop-lvl" id="lvl-magnet">Lv. 0</span>
                <span class="shop-cost" id="cost-magnet">150 G</span>
                <button onclick="app.buyUpgrade('magnet')">UPGRADE</button>
            </div>
            <div class="shop-item">
                <h3>GOLD SCANNER</h3>
                <p>Start with +10% Gold Gain</p>
                <span class="shop-lvl" id="lvl-greed">Lv. 0</span>
                <span class="shop-cost" id="cost-greed">200 G</span>
                <button onclick="app.buyUpgrade('greed')">UPGRADE</button>
            </div>
        </div>
        <button onclick="app.closeShop()" class="secondary">BACK</button>
    </div>

    <!-- HUD -->
    <div id="hud" class="hidden">
        <!-- Top Center Container -->
        <div class="hud-top-container">
            <div class="resource-row">
                <div class="gold-text">GOLD: <span id="ui-gold">0</span></div>
                <div>SCORE: <span id="ui-score">0</span></div>
            </div>
            <div class="wave-info">WAVE <span id="ui-wave">1</span></div>
            
            <!-- XP Bar (Compact) -->
            <div style="width: 200px; height: 4px; background: rgba(255,255,255,0.2); border-radius: 2px; margin-top: 5px; overflow: hidden;">
                <div id="xp-fill" style="height: 100%; width: 0%; background: #00ffcc; transition: width 0.2s;"></div>
            </div>
            <div style="font-size:10px; color:#aaa;">LV <span id="ui-level">1</span></div>
        </div>
        
        <!-- Stats Panel (Responsive Position) -->
        <div class="stats-panel">
            <div style="font-weight:bold; color:white; margin-bottom:2px;">STATUS</div>
            <div>ATK: <span id="stat-atk" style="color:#00f3ff;">10</span></div>
            <div>DPS: <span id="stat-dps" style="color:#ffd700;">0</span></div>
            <div>HP: <span id="stat-hp" style="color:#ff0055;">100</span></div>
            <div>KILL: <span id="stat-kill" style="color:#ff4444;">0</span></div>
            <div id="stat-items" style="display:flex; flex-wrap:wrap; gap:2px; margin-top:2px;"></div>
        </div>

        <!-- HP Bar (Bottom) -->
        <div class="hp-bar-container">
            <div id="hp-fill"></div>
        </div>
    </div>

    <!-- Level Up -->
    <div id="levelup-screen" class="screen hidden">
        <h1 style="color:var(--neon-blue)">SYSTEM UPGRADE</h1>
        <div class="card-container" id="card-container"></div>
    </div>

    <!-- Game Over -->
    <div id="game-over-screen" class="screen hidden">
        <h1 style="color:var(--neon-red); font-size:60px;">MISSION FAILED</h1>
        <p style="font-size:24px;">EARNED: <span id="final-gold" style="color:var(--gold)">0</span> G</p>
        <button onclick="app.toMenu()">RETURN TO BASE</button>
    </div>
</div>

<script>
    /** --- SYSTEM: Persistence & Logic --- */
    const SAVE_KEY = 'moripin_save_v1';
    
    const GameState = {
        MENU: 0,
        PLAYING: 1,
        PAUSED: 2,
        GAMEOVER: 3
    };

    class SaveSystem {
        constructor() {
            this.data = this.load();
        }
        load() {
            const str = localStorage.getItem(SAVE_KEY);
            return str ? JSON.parse(str) : {
                gold: 0,
                upgrades: { maxHp: 0, magnet: 0, greed: 0 }
            };
        }
        save() {
            localStorage.setItem(SAVE_KEY, JSON.stringify(this.data));
        }
        getUpgradeCost(key) {
            const base = { maxHp: 100, magnet: 150, greed: 200 };
            const lvl = this.data.upgrades[key];
            return Math.floor(base[key] * Math.pow(1.5, lvl));
        }
        buy(key) {
            const cost = this.getUpgradeCost(key);
            if (this.data.gold >= cost) {
                this.data.gold -= cost;
                this.data.upgrades[key]++;
                this.save();
                return true;
            }
            return false;
        }
    }

    const saveData = new SaveSystem();

    /** --- GAME ENGINE --- */
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    let width, height;
    function resize() {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    const mouse = { x: width/2, y: height/2 };
    window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });

    // Audio (Minimal Implementation)
    const audio = {
        ctx: null,
        playTone() {},
        shoot() {},
        hit() {},
        explode() {}
    };

    /** --- ENTITIES --- */
    class Camera {
        constructor() { this.x=0; this.y=0; this.zoom=1; }
        update(target, score) {
            // Mobile Zoom Logic: Start zoomed out more (0.6)
            // Zoom Factor: 0.7 (Base) - (score * ...)
            const baseZoom = window.innerWidth < 768 ? 0.6 : 0.8;
            const zoomFactor = Math.max(0.4, baseZoom - (score * 0.00005)); 
            
            this.zoom += (zoomFactor - this.zoom) * 0.05;

            const visibleWidth = width / this.zoom;
            const visibleHeight = height / this.zoom;

            const tx = target.x - visibleWidth/2;
            const ty = target.y - visibleHeight/2;

            this.x += (tx - this.x) * 0.1;
            this.y += (ty - this.y) * 0.1;
            
            // Clamping logic removed or simplified if world is infinite, but keeping clamping for safety if needed
            // Assuming SETTINGS is available globally
            // this.x = Math.max(0, Math.min(this.x, SETTINGS.worldWidth - visibleWidth));
            // this.y = Math.max(0, Math.min(this.y, SETTINGS.worldHeight - visibleHeight));
        }

        apply(ctx) {
            ctx.translate(-this.x, -this.y);
        }
        reset(ctx) { ctx.setTransform(1,0,0,1,0,0); }
    }

    /** --- STATS & LOGIC --- */
    class ElementalStats {
        constructor() {
            this.fire = 0; this.ice = 0; this.volt = 0;
            this.fusions = { steam: false, plasma: false, superconductor: false };
        }
    }

    class StatusManager {
        constructor(owner) {
            this.owner = owner;
            this.burn = { active: false, dps: 0, timer: 0 };
            this.chill = { active: false, slowFactor: 0, timer: 0 };
        }
        applyBurn(dps, duration) {
            this.burn.active = true;
            this.burn.dps = Math.max(this.burn.dps, dps);
            this.burn.timer = duration;
        }
        applyChill(slow, duration) {
            this.chill.active = true;
            this.chill.slowFactor = Math.max(this.chill.slowFactor, slow);
            this.chill.timer = duration;
        }
        update() {
            if (this.burn.active) {
                if (this.owner.hp > 0 && this.burn.timer % 30 === 0) {
                    this.owner.hp -= this.burn.dps * 0.5; // DoT
                }
                this.burn.timer--;
                if (this.burn.timer <= 0) this.burn.active = false;
            }
            if (this.chill.active) {
                this.chill.timer--;
                if (this.chill.timer <= 0) { this.chill.active = false; this.chill.slowFactor = 0; }
            }
        }
        getSpeedMultiplier() {
            return this.chill.active ? (1 - this.chill.slowFactor) : 1;
        }
    }

    class Starship {
        constructor(isAuto = false) {
            this.x = window.innerWidth / 2;
            this.y = window.innerHeight - 100;
            this.isAuto = isAuto;
            
            // Meta Progression Stats
            const ups = saveData.data.upgrades;
            this.maxHp = 100 + (ups.maxHp * 20);
            this.hp = this.maxHp;
            this.magnetRange = 100 + (ups.magnet * 30);
            
            // In-Game Stats
            this.angle = 0;
            this.speed = 6;
            this.radius = 20; // Radius fix
            this.cooldown = 0;
            this.level = 1;
            this.xp = 0;
            this.xpNext = 100;
            
            // Weapons & Items
            this.elements = new ElementalStats();
            this.weapons = {
                multishot: 0,
                damage: 10,
                pierce: 0
            };
            
            // Tech
            this.droneCount = 0;
            this.droneTier = 1;
            this.drones = [];
            
            this.gravityLevel = 0;
            this.gravityTimer = 0;
            this.gravityFields = [];
        }

        update(game) {
            // Fixed Y Position (Bottom of screen)
            this.y = window.innerHeight - 100;
            
            // --- Improved Auto-Targeting (Prioritize Danger & Proximity) ---
            let target = null;
            let minWeight = Infinity;
            
            game.enemies.forEach(e => {
                const dx = e.x - this.x;
                const dy = e.y - this.y;
                const dist = Math.hypot(dx, dy);
                
                // Weighting Formula:
                // We want to prioritize enemies that are LOWER (larger Y)
                // and horizontally closer (smaller abs(dx)).
                // Priority = Distance + (Distance to bottom * 0.5)
                // This makes lower enemies much more attractive targets.
                const weight = dist + (window.innerHeight - e.y) * 0.5;
                
                if (weight < minWeight) {
                    minWeight = weight;
                    target = e;
                }
            });

            if (target) {
                this.angle = Math.atan2(target.y - this.y, target.x - this.x);
            } else {
                this.angle = -Math.PI / 2; // Default: Up
            }

            if (this.isAuto) {
                // Auto Pilot: Move towards nearest enemy X but stay at bottom
                if (target) {
                    if (target.x > this.x + 5) this.x += this.speed * 0.5;
                    else if (target.x < this.x - 5) this.x -= this.speed * 0.5;
                }
                
                if (this.cooldown <= 0) {
                    this.shoot(game);
                    this.cooldown = 20;
                }
                if (this.cooldown > 0) this.cooldown--;
            } else {
                // Player Control: Left/Right Only
                let mx = 0;
                if (game.keys.a) mx -= 1;
                if (game.keys.d) mx += 1;
                
                if (game.joystick.active) {
                    mx = game.joystick.vector.x;
                }

                // Protect against NaN
                if (isNaN(mx)) mx = 0;

                this.x += mx * this.speed;
                if (isNaN(this.x)) this.x = window.innerWidth / 2; // Emergency reset
                
                // Screen Bounds Clamp (Use window.innerWidth)
                this.x = Math.max(this.radius, Math.min(window.innerWidth - this.radius, this.x));

                // Shoot
                if (this.cooldown > 0) this.cooldown--;
                else {
                    this.shoot(game);
                    this.cooldown = Math.max(5, 20 - (this.level * 0.2) - (this.elements.volt)); 
                }
            }

            // --- TECH UPDATE ---
            // Drones
            if (this.drones.length !== this.droneCount) {
                this.drones = [];
                for(let i=0; i<this.droneCount; i++) this.drones.push(new Drone(this, i, this.droneCount));
            }
            this.drones.forEach(d => d.update(game));

            // Gravity
            if (this.gravityLevel > 0) {
                this.gravityTimer--;
                if (this.gravityTimer <= 0) {
                    // Fire in the direction the ship is aiming
                    this.gravityFields.push(new GravityField(this.x, this.y, this.angle, this.gravityLevel));
                    this.gravityTimer = 300 - (this.gravityLevel*20);
                }
            }
            this.gravityFields.forEach(g => g.update(game));
            this.gravityFields = this.gravityFields.filter(g => g.life > 0);
        }

        shoot(game) {
            const count = 1 + this.weapons.multishot;
            const spacing = 15; // Gap between parallel missiles
            
            // Stats calc
            let dmg = this.weapons.damage + (this.elements.fire * 3);
            let color = '#ff0055';
            if (this.elements.fire > 0) color = '#ff4444';
            if (this.elements.ice > 0) color = '#00f3ff';
            if (this.elements.volt > 0) color = '#ffd700';
            
            for(let i=0; i<count; i++) {
                // Calculate perpendicular offset for parallel firing
                // The offset should be perpendicular to the direction of travel (this.angle)
                const offset = (i - (count - 1) / 2) * spacing;
                
                // Perpendicular angle
                const perpAngle = this.angle + Math.PI / 2;
                
                const ox = Math.cos(perpAngle) * offset;
                const oy = Math.sin(perpAngle) * offset;

                game.bullets.push(new Bullet(this.x + ox, this.y + oy, this.angle, dmg, this.weapons.pierce, color));
            }
            // audio.shoot(); // Sound Removed
        }

        draw(ctx) {
            // Safety Net: Force position if out of bounds (Bug fix)
            if (this.x <= 0 || this.x > window.innerWidth) {
                this.x = window.innerWidth / 2;
            }
            // Force Y position for visibility safety
            const safeY = ctx.canvas.height - 100;
            this.y = safeY; 

            // Draw Tech First (Behind ship)
            this.drones.forEach(d => d.draw(ctx));
            this.gravityFields.forEach(g => g.draw(ctx));

            ctx.save();
            ctx.translate(this.x, this.y);
            // Removed rotation for fixed shooter mode to guarantee it points UP.
            
            // X-Wing Style Ship
            ctx.fillStyle = '#00ffcc'; // Brighter Color
            // Body
            ctx.beginPath(); ctx.moveTo(0, -20); ctx.lineTo(6, 10); ctx.lineTo(0, 15); ctx.lineTo(-6, 10); ctx.fill();
            
            // Wings
            ctx.fillStyle = '#aaaaaa';
            ctx.beginPath(); ctx.moveTo(6, 0); ctx.lineTo(30, 10); ctx.lineTo(30, -5); ctx.lineTo(6, -5); ctx.fill();
            ctx.beginPath(); ctx.moveTo(-6, 0); ctx.lineTo(-30, 10); ctx.lineTo(-30, -5); ctx.lineTo(-6, -5); ctx.fill();

            // Cockpit
            ctx.fillStyle = '#ff0055';
            ctx.beginPath(); ctx.moveTo(0, -5); ctx.lineTo(3, 5); ctx.lineTo(-3, 5); ctx.fill();

            // Engines (Thrust)
            ctx.fillStyle = '#00f3ff';
            ctx.shadowBlur = 15; ctx.shadowColor = '#00f3ff';
            ctx.beginPath(); ctx.arc(-10, 12, 4, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(10, 12, 4, 0, Math.PI*2); ctx.fill();
            ctx.shadowBlur = 0;

            ctx.restore();
        }

        gainXp(amount) {
            this.xp += amount;
            if (this.xp >= this.xpNext) {
                this.xp = 0;
                this.level++;
                this.xpNext = Math.floor(this.xpNext * 1.2);
                
                // Heal & MaxHP Up
                this.maxHp += 20;
                this.hp = this.maxHp;
                
                return true; // Leveled Up
            }
            return false;
        }

        takeDamage(amount) {
            if (this.invulnerableTime > 0) return false;
            this.hp = Math.max(0, this.hp - amount);
            this.invulnerableTime = 15; // 0.25s at 60fps
            return this.hp <= 0;
        }
    }

    class Drone {
        constructor(owner, index, total) {
            this.owner = owner;
            this.index = index;
            this.total = total;
            this.x = owner.x; this.y = owner.y;
            this.cooldown = 0;
            this.floatOffset = Math.random()*10;
        }
        update(game) {
            // Formation Follow
            const angleOffset = (Math.PI * 2 / this.total) * this.index;
            const idealX = this.owner.x + Math.cos(game.frame * 0.02 + angleOffset) * 60;
            const idealY = this.owner.y + Math.sin(game.frame * 0.02 + angleOffset) * 60;
            this.x += (idealX - this.x) * 0.1;
            this.y += (idealY - this.y) * 0.1;
            
            // Combat
            if (this.cooldown > 0) this.cooldown--;
            else {
                let target = null, minDist = 400;
                game.enemies.forEach(e => {
                    const d = Math.hypot(e.x - this.x, e.y - this.y);
                    if (d < minDist) { minDist = d; target = e; }
                });
                if (target) {
                    const angle = Math.atan2(target.y - this.y, target.x - this.x);
                    const tier = this.owner.droneTier;
                    const dmg = 5 + (this.owner.level*0.5) + (tier*2);
                    game.bullets.push(new Bullet(this.x, this.y, angle, dmg, tier>=5?1:0, '#00ffff'));
                    this.cooldown = Math.max(5, 50 - (tier*4));
                }
            }
        }
        draw(ctx) {
            ctx.fillStyle = '#333'; ctx.beginPath(); ctx.arc(this.x, this.y, 6, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#00ffff'; ctx.beginPath(); ctx.arc(this.x, this.y, 3, 0, Math.PI*2); ctx.fill();
        }
    }

    class GravityField {
        constructor(x, y, angle, level) {
            this.x = x;
            this.y = y;
            this.angle = angle;
            this.level = level;
            
            // Kinetic Pusher Phase - Starts small and weak
            this.speed = 3 + (level * 0.5);
            this.vx = Math.cos(angle) * this.speed;
            this.vy = Math.sin(angle) * this.speed;
            
            this.radius = 30 + (level * 10);
            this.life = 100 + (level * 15); 
            this.damage = 1 + (level * 2);
        }

        update(game) {
            this.x += this.vx;
            this.y += this.vy;
            this.life--;
            
            // Push enemies in the direction of the projectile
            game.enemies.forEach(e => {
                const dist = Math.hypot(e.x - this.x, e.y - this.y);
                if (dist < this.radius) {
                    // Apply heavy knockback force in the same direction this is flying
                    e.x += this.vx * 1.2;
                    e.y += this.vy * 1.2;
                    
                    // Small continuous damage while pushed
                    e.hp -= this.damage * 0.1;
                    
                    // Visual feedback
                    if (Math.random() < 0.2) {
                        game.spawnParticles(e.x, e.y, '#aa00ff', 1);
                    }
                }
            });
        }

        draw(ctx) {
            ctx.save();
            ctx.translate(this.x, this.y);
            
            // Draw as a powerful energy wave / blast
            ctx.globalAlpha = Math.min(0.6, this.life / 30);
            
            // Glowing core
            const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius);
            grad.addColorStop(0, '#aa00ff');
            grad.addColorStop(0.5, 'rgba(0, 243, 255, 0.5)');
            grad.addColorStop(1, 'transparent');
            
            ctx.fillStyle = grad;
            ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, Math.PI*2); ctx.fill();
            
            // Wave front
            ctx.rotate(this.angle);
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(0, 0, this.radius * 0.8, -Math.PI/3, Math.PI/3);
            ctx.stroke();

            ctx.restore();
        }
    }

    class Bullet {
        constructor(x, y, a, dmg, pierce=0, color='#ff0055') {
            this.x=x; this.y=y; this.vx=Math.cos(a)*15; this.vy=Math.sin(a)*15;
            this.dmg=dmg; this.pierce=pierce; this.color=color;
            this.life=60;
            this.hitList = [];
        }
        update() { this.x+=this.vx; this.y+=this.vy; this.life--; }
        draw(ctx) {
            ctx.fillStyle = this.color;
            ctx.shadowBlur = 5; ctx.shadowColor = this.color;
            ctx.beginPath(); ctx.arc(this.x, this.y, 4, 0, Math.PI*2); ctx.fill();
            ctx.shadowBlur = 0;
        }
    }

    class Enemy {
        constructor(game, type, difficulty) {
            this.type = type || 'small';
            this.x = 0; // Set by spawner
            this.y = 0; 
            
            const hpMult = difficulty * (1 + game.wave * 0.1); // More aggressive scaling
            this.attackDamage = 20 + (game.wave * 5); // Hits harder every wave

            if (this.type === 'large') {
                this.hp = 120 * hpMult;
                this.radius = 25;
                this.color = '#0088ff';
                this.xpValue = 30;
            } else if (this.type === 'medium') {
                this.hp = 50 * hpMult;
                this.radius = 15;
                this.color = '#88ff00';
                this.xpValue = 15;
            } else {
                this.hp = 20 * hpMult;
                this.radius = 10;
                this.color = '#ff8800';
                this.xpValue = 10;
            }
            
            this.maxHp = this.hp;
            this.status = new StatusManager(this);
            this.flashTime = 0;
        }
        update(target) {
            this.status.update();
            if (this.flashTime > 0) this.flashTime--;
        }
                draw(ctx) {
                    // Status Color Overrides
                    if (this.status.chill.active) ctx.fillStyle = '#00ffff';
                    else if (this.flashTime > 0) ctx.fillStyle = '#fff';
                    else ctx.fillStyle = this.color;
        
                    // Render as Square
                    ctx.beginPath();
                    ctx.rect(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
                    ctx.fill();
                    
                    // HP Bar (Always Visible)
            const barWidth = this.radius * 2;
            const barY = this.y - this.radius - 10;
            
            ctx.fillStyle = 'red'; 
            ctx.fillRect(this.x - this.radius, barY, barWidth, 4);
            
            const hpPercent = Math.max(0, this.hp) / this.maxHp;
            ctx.fillStyle = '#0f0'; 
            ctx.fillRect(this.x - this.radius, barY, barWidth * hpPercent, 4);

            // Burn Effect Particle (Visual only)
            if (this.status.burn.active && Math.random() < 0.3) {
                ctx.fillStyle = '#ff4400';
                ctx.beginPath(); ctx.arc(this.x + (Math.random()-0.5)*10, this.y + (Math.random()-0.5)*10, 3, 0, Math.PI*2); ctx.fill();
            }
        }
    }

    class Item {
        constructor(x, y, type) {
            this.x=x; this.y=y; this.type=type; this.magnet=false;
        }
        update(p) {
            let dist = Math.hypot(p.x - this.x, p.y - this.y);
            if (dist < 150) this.magnet = true; // Fixed pickup range
            if (this.magnet) {
                this.x += (p.x - this.x) * 0.15;
                this.y += (p.y - this.y) * 0.15;
                if (dist < 30) return true; // Picked
            }
            return false;
        }
        draw(ctx) {
            if (this.type === 'gold') {
                ctx.fillStyle = '#ffd700';
                ctx.beginPath(); ctx.arc(this.x, this.y, 6, 0, Math.PI*2); ctx.fill();
            } else if (this.type === 'heart') {
                ctx.fillStyle = '#ff3333';
                ctx.beginPath(); ctx.arc(this.x, this.y, 6, 0, Math.PI*2); ctx.fill();
            }
        }
    }

    /** --- INPUT & TOUCH --- */
    class Joystick {
        constructor() {
            this.active = false;
            this.origin = { x: 0, y: 0 };
            this.current = { x: 0, y: 0 };
            this.vector = { x: 0, y: 0 }; 
            
            // Touch Events
            // passive: false to allow preventDefault (if needed for scroll lock)
            // But we must NOT preventDefault if target is button/UI
            window.addEventListener('touchstart', e => this.start(e), {passive: false});
            window.addEventListener('touchmove', e => this.move(e), {passive: false});
            window.addEventListener('touchend', () => this.end());
        }
        
        start(e) {
            // UI 터치 시 조이스틱 발동 안함
            if (e.target.tagName === 'BUTTON' || e.target.closest('.card')) return;
            
            e.preventDefault(); // Prevent scroll/zoom on game area
            this.active = true;
            this.origin.x = e.touches[0].clientX;
            this.origin.y = e.touches[0].clientY;
            this.current.x = this.origin.x;
            this.current.y = this.origin.y;
            this.vector.x = 0; this.vector.y = 0;
        }
        
        move(e) {
            if (!this.active) return;
            e.preventDefault();
            this.current.x = e.touches[0].clientX;
            this.current.y = e.touches[0].clientY;
            
            const dx = this.current.x - this.origin.x;
            const dy = this.current.y - this.origin.y;
            const dist = Math.hypot(dx, dy);
            const maxDist = 50; 
            
            // Prevent division by zero
            if (dist === 0) {
                this.vector.x = 0;
                this.vector.y = 0;
                return;
            }
            
            if (dist > maxDist) {
                this.vector.x = (dx / dist);
                this.vector.y = (dy / dist);
            } else {
                this.vector.x = dx / maxDist;
                this.vector.y = dy / maxDist;
            }
        }
        
        end() {
            this.active = false;
            this.vector.x = 0; this.vector.y = 0;
        }

        draw(ctx) {
            if (!this.active) return;
            // Draw Joystick
            ctx.save();
            ctx.globalAlpha = 0.5;
            
            // Base
            ctx.beginPath();
            ctx.arc(this.origin.x, this.origin.y, 50, 0, Math.PI*2);
            ctx.fillStyle = '#444';
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Stick
            ctx.beginPath();
            // Clamp stick visually
            const dx = this.current.x - this.origin.x;
            const dy = this.current.y - this.origin.y;
            const dist = Math.hypot(dx, dy);
            const maxDist = 50;
            let stickX = this.current.x;
            let stickY = this.current.y;
            
            if (dist > maxDist) {
                stickX = this.origin.x + (dx/dist)*maxDist;
                stickY = this.origin.y + (dy/dist)*maxDist;
            }

            ctx.arc(stickX, stickY, 20, 0, Math.PI*2);
            ctx.fillStyle = '#00f3ff';
            ctx.fill();
            
            ctx.restore();
        }
    }

    class Particle {
        constructor(x, y, color, speed, size, life) {
            this.x = x; this.y = y; this.color = color;
            const angle = Math.random() * Math.PI * 2;
            this.vx = Math.cos(angle) * speed; this.vy = Math.sin(angle) * speed;
            this.life = life; this.maxLife = life; this.size = size;
        }
        update() {
            this.x += this.vx; this.y += this.vy;
            this.vx *= 0.92; this.vy *= 0.92;
            this.life--;
        }
        draw(ctx) {
            ctx.globalAlpha = this.life / this.maxLife;
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
            ctx.fill();
            ctx.globalAlpha = 1;
        }
    }

    class App {
        constructor() {
            this.state = GameState.MENU;
            this.joystick = new Joystick(); // Init Joystick
            this.player = new Starship(true);
            this.camera = new Camera();
            this.enemies = [];
            this.bullets = [];
            this.items = [];
            this.particles = [];
            this.frame = 0;
            this.keys = { w:false, a:false, s:false, d:false };
            this.gold = 0;
            this.score = 0;
            this.wave = 1;
            this.enemiesKilled = 0;
            
            // Invader Logic
            this.enemyDirection = 1;
            this.enemyMoveSpeed = 0.3; // Even slower
            this.enemyDropDistance = 10; // Slower drop

            window.addEventListener('keydown', e => this.keys[e.key.toLowerCase()] = true);
            window.addEventListener('keyup', e => this.keys[e.key.toLowerCase()] = false);

            this.updateMenuUI();
            this.spawnWave();

            this.loop = this.loop.bind(this);
            requestAnimationFrame(this.loop);
        }

        startGame() {
            this.state = GameState.PLAYING;
            this.player = new Starship(false); // Real player
            // Force Bottom Center Position
            this.player.x = window.innerWidth / 2;
            this.player.y = window.innerHeight - 100;
            
            this.enemies = [];
            this.bullets = [];
            this.items = [];
            this.score = 0;
            this.gold = 0;
            this.wave = 1;
            this.enemiesKilled = 0;
            
            // Invader Logic
            this.enemyDirection = 1;
            this.enemyMoveSpeed = 0.4; // Slower base
            this.enemyDropDistance = 5; // Much slower drop
            this.spawnWave(); // Start First Wave
            
            document.getElementById('main-menu').classList.add('hidden');
            document.getElementById('hud').classList.remove('hidden');
            document.getElementById('game-over-screen').classList.add('hidden');
        }

        openShop() {
            this.updateMenuUI();
            document.getElementById('main-menu').classList.add('hidden');
            document.getElementById('shop-screen').classList.remove('hidden');
        }

        closeShop() {
            document.getElementById('shop-screen').classList.add('hidden');
            document.getElementById('main-menu').classList.remove('hidden');
        }

        buyUpgrade(key) {
            if (saveData.buy(key)) {
                this.updateMenuUI();
                // Play coin sound
                audio.playTone(800, 'sine', 0.1);
            } else {
                // Error sound
                audio.playTone(150, 'square', 0.2);
            }
        }

        spawnWave() {
            // Spawn Grid of Enemies (Space Invaders Style)
            const padding = 10;
            const availableWidth = width - (padding * 2);
            
            let pattern = 'small';
            if (this.wave > 2) pattern = 'mixed';
            if (this.wave > 4) pattern = 'heavy';

            // Base Grid Size (Denser)
            const cellSize = 20; 
            const cols = Math.floor(availableWidth / cellSize);
            let startY = 40;
            
            // Add rows based on wave difficulty (More aggressive growth)
            const totalRows = 6 + Math.floor(this.wave / 1.1); 

            for(let r=0; r<totalRows; r++) {
                let rowType = 'small';
                if (pattern === 'mixed' && r % 4 === 0) rowType = 'medium';
                if (pattern === 'heavy' && r % 6 === 0) rowType = 'large';

                let step = 1;
                if (rowType === 'medium') step = 2;
                if (rowType === 'large') step = 4;
                
                for(let c=0; c<cols; c+=step) {
                    if (c + step > cols) break;

                    const e = new Enemy(this, rowType, 1 + this.wave * 0.1);
                    
                    const blockWidth = step * cellSize;
                    const cx = padding + (c * cellSize) + (blockWidth / 2);
                    const cy = startY + (r * 22); // Tighter vertical spacing

                    e.x = cx;
                    e.y = cy;
                    this.enemies.push(e);
                }
                
                if (rowType === 'large') startY += 15;
                else if (rowType === 'medium') startY += 8;
                else startY += 5;
            }
        }

        spawnParticles(x, y, color, count) {
            // Particle logic needs Particle class which is likely global or inside Game previously
            // Assuming Particle class exists globally
            // If not, we might need to add it or skip particle logic for now if it causes errors
            // Let's assume Particle class is there.
             for(let i=0; i<count; i++) {
                // Simple particle simulation
                // Since we don't have a Particle class instance management in App yet (only this.particles array), 
                // we should add it if it's missing or use a simple object
                // Checking previous code, Particle class was defined globally.
                // However, App needs a particles array. Constructor has it.
                // We need to make sure Particle class is available.
                // Assuming it is based on previous context.
                // Wait, Particle class definition was in Game scope in previous versions? 
                // No, it was global.
                // Let's add Particle class logic here just in case or use simple object push
                // Actually, let's just push to this.particles assuming Particle class is defined globally.
                if (typeof Particle !== 'undefined') {
                    this.particles.push(new Particle(x, y, color, Math.random()*3+2, Math.random()*3+1, 20));
                }
            }
        }

        triggerExplosion(x, y, damage) {
            this.spawnParticles(x, y, 'rgba(255,255,255,0.7)', 10);
            this.enemies.forEach(e => {
                if (Math.hypot(e.x - x, e.y - y) < 100) {
                    e.hp -= damage * 0.8;
                }
            });
        }

        triggerChainLightning(sourceEnemy, damage, chainCount) {
            let current = sourceEnemy;
            let visited = [sourceEnemy];
            for (let i = 0; i < chainCount; i++) {
                let closest = null, minDist = 300;
                this.enemies.forEach(e => {
                    if (!visited.includes(e) && Math.hypot(e.x - current.x, e.y - current.y) < minDist) {
                        minDist = Math.hypot(e.x - current.x, e.y - current.y);
                        closest = e;
                    }
                });
                if (closest) {
                    closest.hp -= damage * 0.7;
                    visited.push(closest);
                    this.spawnParticles(closest.x, closest.y, '#ffd700', 3);
                    current = closest;
                } else break;
            }
        }

        triggerMagnetPull(x, y) {
            this.spawnParticles(x, y, '#00ffaa', 5);
            this.enemies.forEach(e => {
                if (Math.hypot(e.x - x, e.y - y) < 200) {
                    e.x += (x - e.x) * 0.1; e.y += (y - e.y) * 0.1;
                }
            });
        }

        updateMenuUI() {
            document.getElementById('menu-gold').innerText = saveData.data.gold;
            document.getElementById('shop-gold-display').innerText = saveData.data.gold;
            
            // Update Costs
            ['maxHp', 'magnet', 'greed'].forEach(key => {
                const lvl = saveData.data.upgrades[key];
                const cost = saveData.getUpgradeCost(key);
                document.getElementById(`lvl-${key}`).innerText = `Lv. ${lvl}`;
                document.getElementById(`cost-${key}`).innerText = `${cost} G`;
            });
        }

        loop() {
            this.frame++;
            
            // Common Logic (Background Simulation)
            if (this.state === GameState.MENU || this.state === GameState.PLAYING) {
                
                // Wave Logic: Start new wave if enemies cleared
                if (this.enemies.length === 0 && this.frame > 60) {
                    if (this.state === GameState.PLAYING) {
                        this.wave++;
                    }
                    this.spawnWave();
                }

                // --- Enemy Movement (Straight Down) ---
                const currentFallSpeed = 0.1 * (1 + this.wave * 0.02); // Even slower fall
                this.enemies.forEach(e => {
                    e.y += currentFallSpeed;
                });

                // Update Entities
                this.player.update(this);
                // Fixed Camera
                // this.camera.update(this.player);

                this.bullets.forEach(b => b.update());
                this.bullets = this.bullets.filter(b => b.life > 0);

                // Enemies Update (Status & Collision)
                this.enemies.forEach(e => {
                    e.update(this.player); // Update status effects
                    
                    // Game Over Check
                    if (e.y > height - 100 && this.state === GameState.PLAYING) {
                        this.gameOver();
                    }
                });
                
                this.items = this.items.filter(i => {
                    if (i.update(this.player)) {
                        // Pickup
                        if (i.type === 'gold') this.gold += 10;
                        else if (i.type === 'heart') this.player.hp = Math.min(this.player.maxHp, this.player.hp + 30);
                        return false;
                    }
                    return true;
                });

                // Collisions
                this.enemies.forEach((e, ei) => {
                    // Bullet vs Enemy
                    this.bullets.forEach((b, bi) => {
                        if (!b.hitList.includes(e) && Math.hypot(e.x - b.x, e.y - b.y) < e.radius + 5) {
                            e.hp -= b.dmg;
                            b.hitList.push(e);
                            if (b.pierce > 0) b.pierce--; else b.life = 0;
                            
                            audio.hit();
                            
                            // Element Effects
                            if (this.player.elements.ice > 0) e.status.applyChill(0.5, 60);
                            if (this.player.elements.fire > 0) e.status.applyBurn(b.dmg*0.5, 60);
                            if (this.player.elements.volt > 0) this.triggerChainLightning(e, b.dmg, 2);

                            if (e.hp <= 0) {
                                audio.explode();
                                if (this.state === GameState.PLAYING) {
                                    this.enemiesKilled++;
                                    this.score += 100;
                                    
                                    // INSTANT XP GAIN (Auto-Loot)
                                    if (this.player.gainXp(10 + (this.wave * 2))) {
                                        this.state = GameState.PAUSED;
                                        this.showLevelUp();
                                    }
                                }
                                // Item drops removed as per user request (Legacy cleanup)
                            }
                        }
                    });
                    
                    // Player vs Enemy (Collision)
                    if (this.state === GameState.PLAYING) {
                        if (Math.hypot(e.x - this.player.x, e.y - this.player.y) < 30) {
                            const dead = this.player.takeDamage(40); // Increased DMG
                            e.hp = 0; // Ramming kills enemy
                            audio.hit();
                            if (dead) {
                                this.gameOver();
                            }
                        }
                    }
                });
                
                this.enemies = this.enemies.filter(e => e.hp > 0);
                
                // Particles
                if (this.particles) {
                    this.particles.forEach(p => p.update());
                    this.particles = this.particles.filter(p => p.life > 0);
                }
            }

            // Draw
            this.draw();
            
            // HUD Update
            if (this.state === GameState.PLAYING) {
                this.updateStatsUI();
            }

            requestAnimationFrame(this.loop);
        }

        updateStatsUI() {
            const p = this.player;
            // Calculate DPS (Approx: Damage * FireRate * Projectiles)
            const firerate = 60 / Math.max(5, 20 - (p.level * 0.2) - p.elements.volt);
            const projectiles = 1 + p.weapons.multishot;
            const dmg = p.weapons.damage + (p.elements.fire * 3);
            const dps = Math.floor(dmg * firerate * projectiles);

            document.getElementById('ui-gold').innerText = this.gold;
            document.getElementById('ui-score').innerText = this.score;
            document.getElementById('ui-level').innerText = p.level;
            
            const xpPct = Math.min(100, (p.xp / p.xpNext) * 100);
            document.getElementById('xp-fill').style.width = xpPct + '%';

            document.getElementById('stat-atk').innerText = Math.floor(dmg);
            document.getElementById('stat-dps').innerText = dps;
            document.getElementById('stat-hp').innerText = Math.floor(p.hp) + '/' + Math.floor(p.maxHp);
            document.getElementById('stat-kill').innerText = this.enemiesKilled || 0;

            // Item Icons
            let icons = '';
            if(p.elements.fire) icons += `<span>🔥${p.elements.fire}</span> `;
            if(p.elements.ice) icons += `<span>❄️${p.elements.ice}</span> `;
            if(p.elements.volt) icons += `<span>⚡${p.elements.volt}</span> `;
            if(p.weapons.multishot) icons += `<span>🏹${p.weapons.multishot}</span> `;
            if(p.weapons.pierce) icons += `<span>🔩${p.weapons.pierce}</span> `;
            if(p.droneCount) icons += `<span>🤖${p.droneCount}</span> `;
            if(p.gravityLevel) icons += `<span>🌌${p.gravityLevel}</span> `;
            
            document.getElementById('stat-items').innerHTML = icons;
        }

        draw() {
            ctx.fillStyle = '#050510';
            ctx.fillRect(0, 0, width, height);
            
            // Stars
            ctx.fillStyle = 'white';
            for(let i=0; i<50; i++) {
                const x = (Math.sin(i*123) * 1000 + this.frame + this.camera.x*0.5) % width;
                const y = (Math.cos(i*321) * 1000 + this.camera.y*0.5) % height;
                ctx.fillRect(x<0?x+width:x, y<0?y+height:y, 2, 2);
            }

            this.camera.apply(ctx);
            
            if (this.particles) this.particles.forEach(p => p.draw(ctx));
            
            this.items.forEach(i => i.draw(ctx));
            this.bullets.forEach(b => b.draw(ctx));
            this.enemies.forEach(e => e.draw(ctx));
            
            this.camera.reset(ctx);
            
            // Draw Player in Screen Space (Fixed UI Layer)
            this.player.draw(ctx);
        }

        showLevelUp() {
            const container = document.getElementById('card-container');
            container.innerHTML = '';
            
            const p = this.player;
            const pool = [
                { id:'fire', name:'Fire Essence', desc:'Damage +3', icon:'🔥' },
                { id:'ice', name:'Ice Crystal', desc:'Slows Enemies', icon:'❄️' },
                { id:'volt', name:'High Voltage', desc:'Fire Rate +', icon:'⚡' },
                { id:'multi', name:'Multi-Shot', desc:'Projectile +1', icon:'🏹' },
                { id:'pierce', name:'Drill Ammo', desc:'Pierce +1', icon:'🔩' },
                { id:'gravity', name:'Kinetic Blast', desc:'Push enemies back', icon:'🌌' }
            ];
            
            if (p.droneCount < 5) pool.push({ id:'drone_add', name:'Deploy Drone', desc:'Add Companion', icon:'🤖' });
            if (p.droneCount > 0) pool.push({ id:'drone_up', name:'Drone Chip', desc:'Upgrade Drones', icon:'💾' });
            
            // Random 3 Unique
            const choices = [];
            const temp = [...pool];
            for(let i=0; i<3; i++) {
                if(temp.length===0) break;
                const idx = Math.floor(Math.random()*temp.length);
                choices.push(temp[idx]);
                temp.splice(idx, 1);
            }
            
            choices.forEach(u => {
                const div = document.createElement('div');
                div.className = 'card';
                div.innerHTML = `<div class="card-icon">${u.icon}</div><div class="card-title">${u.name}</div><div class="card-desc">${u.desc}</div>`;
                div.onclick = () => {
                    if(u.id==='fire') p.elements.fire++;
                    if(u.id==='ice') p.elements.ice++;
                    if(u.id==='volt') p.elements.volt++;
                    if(u.id==='multi') p.weapons.multishot++;
                    if(u.id==='pierce') p.weapons.pierce++;
                    if(u.id==='gravity') p.gravityLevel++;
                    if(u.id==='drone_add') p.droneCount++;
                    if(u.id==='drone_up') p.droneTier++;
                    
                    document.getElementById('levelup-screen').classList.add('hidden');
                    this.state = GameState.PLAYING;
                };
                container.appendChild(div);
            });
            
            document.getElementById('levelup-screen').classList.remove('hidden');
        }

        gameOver() {
            this.state = GameState.GAMEOVER;
            saveData.data.gold += this.gold;
            saveData.save();
            
            document.getElementById('final-gold').innerText = this.gold;
            document.getElementById('game-over-screen').classList.remove('hidden');
            document.getElementById('hud').classList.add('hidden');
        }

        toMenu() {
            this.updateMenuUI();
            document.getElementById('game-over-screen').classList.add('hidden');
            document.getElementById('main-menu').classList.remove('hidden');
            this.player = new Starship(true); // Restart demo
            this.state = GameState.MENU;
        }
    }

    const app = new App();

</script>
</body>
</html>